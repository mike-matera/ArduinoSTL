#pragma once
#ifdef ARDUINO_ARCH_SAM
#include CSL_Official(ratio)
#endif
#include "cstdint"
#include "type_traits"
_STD_BEGIN
_NODISCARD constexpr intmax_t _Abs(const intmax_t _Val) noexcept
{
	return _Val < 0 ? -_Val : _Val;
}

template <intmax_t _Ax, intmax_t _Bx, bool _Sfinae = false,
		  bool _Good = _Abs(_Ax) <= INTMAX_MAX / (_Bx == 0 ? 1 : _Abs(_Bx))>
struct _Safe_mult : integral_constant<intmax_t, _Ax * _Bx>
{
}; // computes _Ax * _Bx without overflow

template <intmax_t _Ax, intmax_t _Bx, bool _Sfinae>
struct _Safe_mult<_Ax, _Bx, _Sfinae, false>
{ // _Ax * _Bx would overflow
	static_assert(_Sfinae, "integer arithmetic overflow");
};

_NODISCARD constexpr intmax_t _Sign_of(const intmax_t _Val) noexcept
{
	return _Val < 0 ? -1 : 1;
}
// 37
// 47
#if _HAS_CXX14
_NODISCARD constexpr intmax_t _Gcd(intmax_t _Ax, intmax_t _Bx) noexcept
{
	// computes GCD of abs(_Ax) and abs(_Bx)
	if (_Ax == 0 && _Bx == 0)
	{
		return 1; // contrary to mathematical convention; avoids division by 0 in ratio_less
	}

	_Ax = _Abs(_Ax);
	_Bx = _Abs(_Bx);

	while (_Bx != 0)
	{
		const intmax_t _Ax2 = _Ax;
		_Ax = _Bx;
		_Bx = _Ax2 % _Bx;
	}

	return _Ax;
}
#else
template <intmax_t _Ax, intmax_t _Bx>
struct _Gcd_t : _Gcd_t<_Bx, _Ax % _Bx>
{
};
template <intmax_t _Ax>
struct _Gcd_t<_Ax, 0>
{
	static constexpr intmax_t value = _Ax;
};
template <>
struct _Gcd_t<0, 0>
{
	static constexpr intmax_t value = 1;
};
#define _Gcd(_Ax, _Bx) _Gcd_t<_Ax, _Bx>::value
#endif
_EXPORT_STD template <intmax_t _Nx, intmax_t _Dx = 1>
struct ratio
{ // holds the ratio of _Nx to _Dx
	static_assert(_Dx != 0, "zero denominator");
	static_assert(-INTMAX_MAX <= _Nx, "numerator too negative");
	static_assert(-INTMAX_MAX <= _Dx, "denominator too negative");

	static constexpr intmax_t num = _Sign_of(_Nx) * _Sign_of(_Dx) * _Abs(_Nx) / _Gcd(_Nx, _Dx);
	static constexpr intmax_t den = _Abs(_Dx) / _Gcd(_Nx, _Dx);

	using type = ratio<num, den>;
};
#if _HAS_CXX14
template <class _Ty>
_INLINE_VAR constexpr bool _Is_ratio_v = false; // test for ratio type

template <intmax_t _Rx1, intmax_t _Rx2>
_INLINE_VAR constexpr bool _Is_ratio_v<ratio<_Rx1, _Rx2>> = true;
#endif
template <class _Ty>
struct _Is_ratio
{
	static constexpr bool value = false; // test for ratio type
};
template <intmax_t _Rx1, intmax_t _Rx2>
struct _Is_ratio<ratio<_Rx1, _Rx2>>
{
	static constexpr bool value = true;
};
// 83
// 115
template <class _Rx1, class _Rx2>
struct _Ratio_multiply
{ // multiply two ratios
	static_assert(_Is_ratio<_Rx1>::value && _Is_ratio<_Rx2>::value, "ratio_multiply<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _Nx1 = _Rx1::num;
	static constexpr intmax_t _Dx1 = _Rx1::den;
	static constexpr intmax_t _Nx2 = _Rx2::num;
	static constexpr intmax_t _Dx2 = _Rx2::den;

	static constexpr intmax_t _Gx = _Gcd(_Nx1, _Dx2);
	static constexpr intmax_t _Gy = _Gcd(_Nx2, _Dx1);

	using _Num = _Safe_mult<_Nx1 / _Gx, _Nx2 / _Gy, true>;
	using _Den = _Safe_mult<_Dx1 / _Gy, _Dx2 / _Gx, true>;
};

template <class _Rx1, class _Rx2, bool _Sfinae = true, class = void>
struct _Ratio_multiply_sfinae
{ // detect overflow during multiplication
	static_assert(_Sfinae, "integer arithmetic overflow");
};

template <class _Rx1, class _Rx2, bool _Sfinae>
struct _Ratio_multiply_sfinae<_Rx1, _Rx2, _Sfinae,
							  void_t<typename _Ratio_multiply<_Rx1, _Rx2>::_Num::type,
									 typename _Ratio_multiply<_Rx1, _Rx2>::_Den::type>>
{ // typename ratio<>::type is unnecessary here
	using type = ratio<_Ratio_multiply<_Rx1, _Rx2>::_Num::value, _Ratio_multiply<_Rx1, _Rx2>::_Den::value>;
};
// 143
//  146
template <class _Rx1, class _Rx2>
struct _Ratio_divide
{ // divide two ratios
	static_assert(_Is_ratio<_Rx1>::value && _Is_ratio<_Rx2>::value, "ratio_divide<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _Nx2 = _Rx2::num;
	static constexpr intmax_t _Dx2 = _Rx2::den;

	using _Rx2_inverse = ratio<_Dx2, _Nx2>;
};

template <class _Rx1, class _Rx2, bool _Sfinae = true>
using _Ratio_divide_sfinae =
	typename _Ratio_multiply_sfinae<_Rx1, typename _Ratio_divide<_Rx1, _Rx2>::_Rx2_inverse, _Sfinae>::type;

_EXPORT_STD template <class _Rx1, class _Rx2>
using ratio_divide = _Ratio_divide_sfinae<_Rx1, _Rx2, false>;
// 163
// 261
_EXPORT_STD using atto = ratio<1, 1000000000000000000LL>;
_EXPORT_STD using femto = ratio<1, 1000000000000000LL>;
_EXPORT_STD using pico = ratio<1, 1000000000000LL>;
_EXPORT_STD using nano = ratio<1, 1000000000>;
_EXPORT_STD using micro = ratio<1, 1000000>;
_EXPORT_STD using milli = ratio<1, 1000>;
_EXPORT_STD using centi = ratio<1, 100>;
_EXPORT_STD using deci = ratio<1, 10>;
_EXPORT_STD using deca = ratio<10, 1>;
_EXPORT_STD using hecto = ratio<100, 1>;
_EXPORT_STD using kilo = ratio<1000, 1>;
_EXPORT_STD using mega = ratio<1000000, 1>;
_EXPORT_STD using giga = ratio<1000000000, 1>;
_EXPORT_STD using tera = ratio<1000000000000LL, 1>;
_EXPORT_STD using peta = ratio<1000000000000000LL, 1>;
_EXPORT_STD using exa = ratio<1000000000000000000LL, 1>;
_STD_END