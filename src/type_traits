/*	Copyright (C) 2005 Garrett A. Kajmowicz

    This file is part of the uClibc++ Library.
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#pragma once
#ifdef ARDUINO_ARCH_AVR
#include "char_traits"
#include "xtr1common"
#include "xstddef"
#include "cstddef"
#else
#include "Cpp_Standard_Library.h"
#include CSL_Official(type_traits)
#include <stddef.h>
#endif
#pragma GCC visibility push(default)

namespace std
{
#ifdef ARDUINO_ARCH_AVR
    struct _UCXXEXPORT __true_type
    {
    };
    struct _UCXXEXPORT __false_type
    {
    };

    template <class I>
    class _UCXXEXPORT __is_integer
    {
    public:
        typedef __false_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<unsigned int>
    {
    public:
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<signed int>
    {
    public:
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<short unsigned int>
    {
    public:
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<short signed int>
    {
    public:
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<char>
    {
    public:
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<signed char>
    {
    public:
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<unsigned char>
    {
    public:
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<long unsigned int>
    {
    public:
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<long signed int>
    {
    public:
        typedef __true_type value;
    };
    // 44
    template <bool _First_value, class _First, class... _Rest>
    struct _Conjunction
    { // handle false trait or last trait
        using type = _First;
    };

    template <class _True, class _Next, class... _Rest>
    struct _Conjunction<true, _True, _Next, _Rest...>
    { // the first trait is true, try the next one
        using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
    };

    template <class... _Traits>
    struct conjunction : true_type
    {
    }; // If _Traits is empty, true_type

    template <class _First, class... _Rest>
    struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type
    {
        // the first false trait in _Traits, or the last trait if none are false
    };
#if _HAS_CXX14
    template <class... _Traits>
    _INLINE_VAR constexpr bool conjunction_v = conjunction<_Traits...>::value;
#endif
    template <class _Trait>
    struct negation : bool_constant<!static_cast<bool>(_Trait::value)>
    {
    }; // The negated result of _Trait
#if _HAS_CXX14
    template <class _Trait>
    _INLINE_VAR constexpr bool negation_v = negation<_Trait>::value;

    template <class _Ty>
    _INLINE_VAR constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;
#endif
    template <class _Ty>
    struct is_void : is_same<remove_cv_t<_Ty>, void>
    {
    };
#endif
#ifdef ARDUINO_ARCH_SAM
    // Workaround SAM 平台的 void_t bug
    template <class... _Types>
    struct void_s
    {
        using type = void;
    };
    template <class T, class... _Types>
    struct void_s<T, _Types...>
    {
        using type = T;
    };
    template <typename... _Types>
    using void_t = typename void_s<_Types...>::type;
#else
    template <class... _Types>
    using void_t = void;
#endif
// 80
#ifdef ARDUINO_ARCH_AVR
    // 105
    template <class _Ty, class = void>
    struct _Add_reference
    { // add reference (non-referenceable type)
        using _Lvalue = _Ty;
        using _Rvalue = _Ty;
    };

    template <class _Ty>
    struct _Add_reference<_Ty, void_t<_Ty &>>
    { // (referenceable type)
        using _Lvalue = _Ty &;
        using _Rvalue = _Ty &&;
    };

    template <class _Ty>
    struct add_lvalue_reference
    {
        using type = typename _Add_reference<_Ty>::_Lvalue;
    };

    template <class _Ty>
    using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

    template <class _Ty>
    struct add_rvalue_reference
    {
        using type = typename _Add_reference<_Ty>::_Rvalue;
    };

    template <class _Ty>
    using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

    template <class _Ty>
    add_rvalue_reference_t<_Ty> declval() noexcept
    {
        static_assert(_STRUCT14VALUE(_Always_false, _Ty), "Calling declval is ill-formed, see N4892 [declval]/2.");
    }
    
    template <class _Ty>
    struct remove_extent
    { // remove array extent
        using type = _Ty;
    };

    template <class _Ty, size_t _Ix>
    struct remove_extent<_Ty[_Ix]>
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_extent<_Ty[]>
    {
        using type = _Ty;
    };
#endif
    template <class _Ty>
    using remove_extent_t = typename remove_extent<_Ty>::type;
#ifdef ARDUINO_ARCH_AVR
    // 156
    // 174
    template <class _Ty>
    struct remove_pointer
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_pointer<_Ty *>
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_pointer<_Ty *const>
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_pointer<_Ty *volatile>
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_pointer<_Ty *const volatile>
    {
        using type = _Ty;
    };

    template <class _Ty>
    using remove_pointer_t = typename remove_pointer<_Ty>::type;

    template <class _Ty, class = void>
    struct _Add_pointer
    { // add pointer (pointer type cannot be formed)
        using type = _Ty;
    };

    template <class _Ty>
    struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty> *>>
    { // (pointer type can be formed)
        using type = remove_reference_t<_Ty> *;
    };

    template <class _Ty>
    struct add_pointer
    {
        using type = typename _Add_pointer<_Ty>::type;
    };

    template <class _Ty>
    using add_pointer_t = typename _Add_pointer<_Ty>::type;
#if _HAS_CXX14
    template <class>
    _INLINE_VAR constexpr bool is_array_v = false; // determine whether type argument is an array

    template <class _Ty, size_t _Nx>
    _INLINE_VAR constexpr bool is_array_v<_Ty[_Nx]> = true;

    template <class _Ty>
    _INLINE_VAR constexpr bool is_array_v<_Ty[]> = true;
#endif
    template <class>
    struct is_array
    {
        static constexpr bool value = false; // determine whether type argument is an array
    };
    template <class _Ty, size_t _Nx>
    struct is_array<_Ty[_Nx]>
    {
        static constexpr bool value = true;
    };
    template <class _Ty>
    struct is_array<_Ty[]>
    {
        static constexpr bool value = true;
    };
// 232
// 252
#if _HAS_CXX14
    template <class>
    _INLINE_VAR constexpr bool is_lvalue_reference_v = false; // determine whether type argument is an lvalue reference

    template <class _Ty>
    _INLINE_VAR constexpr bool is_lvalue_reference_v<_Ty &> = true;
#endif
    template <class>
    struct is_lvalue_reference
    {
        static constexpr bool value = false; // determine whether type argument is an lvalue reference
    };
    template <class _Ty>
    struct is_lvalue_reference<_Ty &>
    {
        static constexpr bool value = true;
    };
// 261
// 270
#if _HAS_CXX14
    template <class>
    _INLINE_VAR constexpr bool is_reference_v = false; // determine whether type argument is a reference

    template <class _Ty>
    _INLINE_VAR constexpr bool is_reference_v<_Ty &> = true;

    template <class _Ty>
    _INLINE_VAR constexpr bool is_reference_v<_Ty &&> = true;
#endif
    template <class>
    struct is_reference
    {
        static constexpr bool value = false; // determine whether type argument is a reference
    };
    template <class _Ty>
    struct is_reference<_Ty &>
    {
        static constexpr bool value = true;
    };

    template <class _Ty>
    struct is_reference<_Ty &&>
    {
        static constexpr bool value = true;
    };
#if _HAS_CXX14
    template <class>
    _INLINE_VAR constexpr bool is_pointer_v = false; // determin_INLINE_VARise whether _Ty is a pointer

    template <class _Ty>
    _INLINE_VAR constexpr bool is_pointer_v<_Ty *> = true;

    template <class _Ty>
    _INLINE_VAR constexpr bool is_pointer_v<_Ty *const> = true;

    template <class _Ty>
    _INLINE_VAR constexpr bool is_pointer_v<_Ty *volatile> = true;

    template <class _Ty>
    _INLINE_VAR constexpr bool is_pointer_v<_Ty *const volatile> = true;
#endif
    template <class>
    struct is_pointer
    {
        static constexpr bool value = false; // determine whether _Ty is a pointer
    };
    template <class _Ty>
    struct is_pointer<_Ty *>
    {
        static constexpr bool value = true;
    };

    template <class _Ty>
    struct is_pointer<_Ty *const>
    {
        static constexpr bool value = true;
    };

    template <class _Ty>
    struct is_pointer<_Ty *volatile>
    {
        static constexpr bool value = true;
    };

    template <class _Ty>
    struct is_pointer<_Ty *const volatile>
    {
        static constexpr bool value = true;
    };
// 300
// 572 故意放在前面，因为要被is_function使用
#if _HAS_CXX14
    template <class>
    _INLINE_VAR constexpr bool is_const_v = false; // determine whether type argument is const qualified

    template <class _Ty>
    _INLINE_VAR constexpr bool is_const_v<const _Ty> = true;
#endif
    template <class>
    struct is_const
    {
        static constexpr bool value = false; // determine whether type argument is const qualified
    };
    template <class _Ty>
    struct is_const<const _Ty>
    {
        static constexpr bool value = true;
    };
// 581
// 590 故意放在前面，因为要被is_convertible使用
#if _HAS_CXX14
    template <class _Ty>
    _INLINE_VAR constexpr bool is_function_v = // only function types and reference types can't be const qualified
        !is_const_v<const _Ty> && !is_reference_v<_Ty>;
#endif
    template <class _Ty>
    struct is_function : bool_constant<!is_const<const _Ty>::value && !is_reference<_Ty>::value>
    {
    };
// 597
// 321
//  VC not well implemented, switch to LLVM, which relies on is_function
#include "__type_traits/is_convertible.h"

    template <class _Ty>
    struct is_enum : bool_constant<__is_enum(_Ty)>
    {
    }; // determine whether _Ty is an enumerated type
#if _HAS_CXX14
    template <class _Ty>
    _INLINE_VAR constexpr bool is_enum_v = __is_enum(_Ty);
#endif
// 361
// 375
#define _EMIT_CDECL(FUNC, OPT1, OPT2, OPT3) FUNC(__cdecl, OPT1, OPT2, OPT3)

#ifdef _M_CEE
#define _EMIT_CLRCALL(FUNC, OPT1, OPT2, OPT3) FUNC(__clrcall, OPT1, OPT2, OPT3)
#else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
#define _EMIT_CLRCALL(FUNC, OPT1, OPT2, OPT3)
#endif // ^^^ !defined(_M_CEE) ^^^

#if defined(_M_IX86) && !defined(_M_CEE)
#define _EMIT_FASTCALL(FUNC, OPT1, OPT2, OPT3) FUNC(__fastcall, OPT1, OPT2, OPT3)

#else // defined(_M_IX86) && !defined(_M_CEE)
#define _EMIT_FASTCALL(FUNC, OPT1, OPT2, OPT3)
#endif // defined(_M_IX86) && !defined(_M_CEE)

#ifdef _M_IX86
#define _EMIT_STDCALL(FUNC, OPT1, OPT2, OPT3) FUNC(__stdcall, OPT1, OPT2, OPT3)
#define _EMIT_THISCALL(FUNC, OPT1, OPT2, OPT3) FUNC(__thiscall, OPT1, OPT2, OPT3)
#else // ^^^ defined(_M_IX86) / !defined(_M_IX86) vvv
#define _EMIT_STDCALL(FUNC, OPT1, OPT2, OPT3)
#define _EMIT_THISCALL(FUNC, OPT1, OPT2, OPT3)
#endif // ^^^ !defined(_M_IX86) ^^^

#if ((defined(_M_IX86) && _M_IX86_FP >= 2) || defined(_M_X64)) && !defined(_M_CEE)
#define _EMIT_VECTORCALL(FUNC, OPT1, OPT2, OPT3) FUNC(__vectorcall, OPT1, OPT2, OPT3)

#else // defined(_M_IX86) && _M_IX86_FP >= 2 etc.
#define _EMIT_VECTORCALL(FUNC, OPT1, OPT2, OPT3)
#endif // defined(_M_IX86) && _M_IX86_FP >= 2 etc.

#define _NON_MEMBER_CALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
    _EMIT_CDECL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)          \
    _EMIT_CLRCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)        \
    _EMIT_FASTCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)       \
    _EMIT_STDCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)        \
    _EMIT_VECTORCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)

#define _NON_MEMBER_CALL_CV(FUNC, REF_OPT, NOEXCEPT_OPT)    \
    _NON_MEMBER_CALL(FUNC, , REF_OPT, NOEXCEPT_OPT)         \
    _NON_MEMBER_CALL(FUNC, const, REF_OPT, NOEXCEPT_OPT)    \
    _NON_MEMBER_CALL(FUNC, volatile, REF_OPT, NOEXCEPT_OPT) \
    _NON_MEMBER_CALL(FUNC, const volatile, REF_OPT, NOEXCEPT_OPT)

#define _NON_MEMBER_CALL_CV_REF(FUNC, NOEXCEPT_OPT) \
    _NON_MEMBER_CALL_CV(FUNC, , NOEXCEPT_OPT)       \
    _NON_MEMBER_CALL_CV(FUNC, &, NOEXCEPT_OPT)      \
    _NON_MEMBER_CALL_CV(FUNC, &&, NOEXCEPT_OPT)

#ifdef __cpp_noexcept_function_type
#define _NON_MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \
    _NON_MEMBER_CALL_CV_REF(FUNC, )            \
    _NON_MEMBER_CALL_CV_REF(FUNC, noexcept)
#else // ^^^ defined(__cpp_noexcept_function_type) / !defined(__cpp_noexcept_function_type) vvv
#define _NON_MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) _NON_MEMBER_CALL_CV_REF(FUNC, )
#endif // ^^^ !defined(__cpp_noexcept_function_type) ^^^

#define _MEMBER_CALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
    _EMIT_CDECL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)      \
    _EMIT_CLRCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)    \
    _EMIT_FASTCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)   \
    _EMIT_STDCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)    \
    _EMIT_THISCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)   \
    _EMIT_VECTORCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)

#define _MEMBER_CALL_CV(FUNC, REF_OPT, NOEXCEPT_OPT)    \
    _MEMBER_CALL(FUNC, , REF_OPT, NOEXCEPT_OPT)         \
    _MEMBER_CALL(FUNC, const, REF_OPT, NOEXCEPT_OPT)    \
    _MEMBER_CALL(FUNC, volatile, REF_OPT, NOEXCEPT_OPT) \
    _MEMBER_CALL(FUNC, const volatile, REF_OPT, NOEXCEPT_OPT)

#define _MEMBER_CALL_CV_REF(FUNC, NOEXCEPT_OPT) \
    _MEMBER_CALL_CV(FUNC, , NOEXCEPT_OPT)       \
    _MEMBER_CALL_CV(FUNC, &, NOEXCEPT_OPT)      \
    _MEMBER_CALL_CV(FUNC, &&, NOEXCEPT_OPT)

#ifdef __cpp_noexcept_function_type
#define _MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \
    _MEMBER_CALL_CV_REF(FUNC, )            \
    _MEMBER_CALL_CV_REF(FUNC, noexcept)
#else // ^^^ defined(__cpp_noexcept_function_type) / !defined(__cpp_noexcept_function_type) vvv
#define _MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) _MEMBER_CALL_CV_REF(FUNC, )
#endif // ^^^ !defined(__cpp_noexcept_function_type) ^^^

#ifdef __cpp_noexcept_function_type
#define _CLASS_DEFINE_CV_REF_NOEXCEPT(CLASS) \
    CLASS(_EMPTY_ARGUMENT)                   \
    CLASS(const)                             \
    CLASS(volatile)                          \
    CLASS(const volatile)                    \
    CLASS(&)                                 \
    CLASS(const &)                           \
    CLASS(volatile &)                        \
    CLASS(const volatile &)                  \
    CLASS(&&)                                \
    CLASS(const &&)                          \
    CLASS(volatile &&)                       \
    CLASS(const volatile &&)                 \
    CLASS(noexcept)                          \
    CLASS(const noexcept)                    \
    CLASS(volatile noexcept)                 \
    CLASS(const volatile noexcept)           \
    CLASS(& noexcept)                        \
    CLASS(const & noexcept)                  \
    CLASS(volatile & noexcept)               \
    CLASS(const volatile & noexcept)         \
    CLASS(&& noexcept)                       \
    CLASS(const && noexcept)                 \
    CLASS(volatile && noexcept)              \
    CLASS(const volatile && noexcept)
#else // ^^^ defined(__cpp_noexcept_function_type) / !defined(__cpp_noexcept_function_type) vvv
#define _CLASS_DEFINE_CV_REF_NOEXCEPT(CLASS) \
    CLASS(_EMPTY_ARGUMENT)                   \
    CLASS(const)                             \
    CLASS(volatile)                          \
    CLASS(const volatile)                    \
    CLASS(&)                                 \
    CLASS(const &)                           \
    CLASS(volatile &)                        \
    CLASS(const volatile &)                  \
    CLASS(&&)                                \
    CLASS(const &&)                          \
    CLASS(volatile &&)                       \
    CLASS(const volatile &&)
#endif // ^^^ !defined(__cpp_noexcept_function_type) ^^^

    template <class... _Types>
    struct _Arg_types
    {
    }; // provide argument_type, etc. when sizeof...(_Types) is 1 or 2

    template <class _Ty1>
    struct _Arg_types<_Ty1>
    {
        using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty1;
    };

    template <class _Ty1, class _Ty2>
    struct _Arg_types<_Ty1, _Ty2>
    {
        using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty1;
        using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty2;
    };

    template <class _Ty>
    struct _Is_memfunptr
    {                                  // base class for member function pointer predicates
        using _Bool_type = false_type; // NB: members are user-visible via _Weak_types
    };

#define _IS_MEMFUNPTR(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT)                                               \
    template <class _Ret, class _Arg0, class... _Types>                                                      \
    struct _Is_memfunptr<_Ret (/*Arduino不支持：CALL_OPT*/ _Arg0::*)(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT> \
        : _Arg_types<CV_OPT _Arg0 *, _Types...>                                                              \
    {                                                                                                        \
        using _Bool_type = true_type;                                                                        \
        using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ret;                                    \
        using _Class_type = _Arg0;                                                                           \
        using _Guide_type = enable_if<!_STRUCT14VALUE_V(is_same, int REF_OPT, int &&), _Ret(_Types...)>;     \
    };

    _MEMBER_CALL_CV_REF_NOEXCEPT(_IS_MEMFUNPTR)
#undef _IS_MEMFUNPTR

#define _IS_MEMFUNPTR_ELLIPSIS(CV_REF_NOEXCEPT_OPT)                       \
    template <class _Ret, class _Arg0, class... _Types>                   \
    struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)                  \
                             CV_REF_NOEXCEPT_OPT>                         \
    { /* no calling conventions for ellipsis */                           \
        using _Bool_type = true_type;                                     \
        using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ret; \
        using _Class_type = _Arg0;                                        \
        using _Guide_type = enable_if<false>;                             \
    };

    _CLASS_DEFINE_CV_REF_NOEXCEPT(_IS_MEMFUNPTR_ELLIPSIS)
#undef _IS_MEMFUNPTR_ELLIPSIS

#if _HAS_CXX23 && !defined(__clang__) // TRANSITION, DevCom-10107077, Clang has not implemented Deducing this
#define _IS_MEMFUNPTR_EXPLICIT_THIS_GUIDES(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
    template <class _Ret, class _Self, class... _Args>                              \
    struct _Is_memfunptr<_Ret(CALL_OPT *)(_Self, _Args...) NOEXCEPT_OPT>            \
    {                                                                               \
        using _Bool_type = false_type;                                              \
        using _Guide_type = _Identity<_Ret(_Args...)>;                              \
    };

    _NON_MEMBER_CALL(_IS_MEMFUNPTR_EXPLICIT_THIS_GUIDES, , , )
#ifdef __cpp_noexcept_function_type
    _NON_MEMBER_CALL(_IS_MEMFUNPTR_EXPLICIT_THIS_GUIDES, , , noexcept)
#endif // defined(__cpp_noexcept_function_type)

#undef _IS_MEMFUNPTR_EXPLICIT_THIS_GUIDES
#endif // _HAS_CXX23 && !defined(__clang__)
#if _HAS_CXX14
#ifdef __clang__
    _EXPORT_STD template <class _Ty>
    _INLINE_VAR constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_Ty);
#else  // ^^^ Clang / Other vvv
    _EXPORT_STD template <class _Ty>
    _INLINE_VAR constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;
#endif // ^^^ Other ^^^

    _EXPORT_STD template <class _Ty>
    struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>>
    {
    };
#else
    _EXPORT_STD template <class _Ty>
    struct is_member_function_pointer : _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type
    {
    };
#endif
    // 572
    //  604
    template <class>
    struct _Is_member_object_pointer
    {
        static constexpr bool value = false;
    };

    template <class _Ty1, class _Ty2>
    struct _Is_member_object_pointer<_Ty1 _Ty2::*>
    {
        static constexpr bool value = !is_function_v<_Ty1>;
        using _Class_type = _Ty2;
    };

#ifdef __clang__
    _EXPORT_STD template <class _Ty>
    _INLINE_VAR constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_Ty);
#else  // ^^^ Clang / Other vvv
    _EXPORT_STD template <class _Ty>
    _INLINE_VAR constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;
#endif // ^^^ Other ^^^

    _EXPORT_STD template <class _Ty>
    struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>>
    {
    };

#ifdef __clang__
    _EXPORT_STD template <class _Ty>
    _INLINE_VAR constexpr bool is_member_pointer_v = __is_member_pointer(_Ty);
#else  // ^^^ Clang / Other vvv
    _EXPORT_STD template <class _Ty>
    _INLINE_VAR constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;
#endif // ^^^ Other ^^^

    _EXPORT_STD template <class _Ty>
    struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>>
    {
    }; // determine whether _Ty is a pointer to member
    // 637
    //  650
    template <class _Ty>
    struct is_empty : bool_constant<__is_empty(_Ty)>
    {
    }; // determine whether _Ty is an empty class
#if _HAS_CXX14
    template <class _Ty>
    _INLINE_VAR constexpr bool is_empty_v = __is_empty(_Ty);
#endif
    // 656
    // 668
    template <class _Ty>
    struct is_final : bool_constant<__is_final(_Ty)>
    {
    }; // determine whether _Ty is a final class
#if _HAS_CXX14
    template <class _Ty>
    _INLINE_VAR constexpr bool is_final_v = __is_final(_Ty);
#endif
// 674
// 749
// VC not well implemented, switch to boost implementation based on boost is_default_constructible
#include "__type_traits/is_constructible.hpp"
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_constructible
    template <class _Ty, class... _Args>
    _INLINE_VAR constexpr bool is_constructible_v = is_constructible<_Ty, _Args...>::value;
#endif
// 757
//  765
//  VC not well implemented, switch to boost implementation
#include "__type_traits/is_default_constructible.hpp"
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_default_constructible
    template <class _Ty>
    _INLINE_VAR constexpr bool is_default_constructible_v = is_default_constructible<_Ty>::value;
#endif
    // 773
    //  785
    //  VC not well implemented, switch to EbolaChan's personal implementation based on boost is_constructible
    template <class _Ty>
    struct is_move_constructible : is_constructible<_Ty, _Ty>
    {
        // determine whether _Ty can be direct-initialized from an rvalue _Ty
    };
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on EbolaChan's is_constructible_v
    template <class _Ty>
    _INLINE_VAR constexpr bool is_move_constructible_v = is_constructible_v<_Ty, _Ty>;
#endif
// VC not well implemented, switch to boost implementation
#include "__type_traits/is_assignable.hpp"
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_assignable
    template <class _To, class _From>
    _INLINE_VAR constexpr bool is_assignable_v = is_assignable<_To, _From>::value;
#endif
    // 799
    // 834
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_assignable
    template <class _Ty>
    struct is_move_assignable : is_assignable<add_lvalue_reference_t<_Ty>, _Ty>
    {
        // determine whether an rvalue _Ty can be assigned to an lvalue _Ty
    };
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on EbolaChan's is_assignable_v
    template <class _Ty>
    _INLINE_VAR constexpr bool is_move_assignable_v = is_assignable_v<add_lvalue_reference_t<_Ty>, _Ty>;
#endif
// 842
// 883
#if _HAS_CXX14
    template <class _Ty>
    _INLINE_VAR constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;
#endif
    template <class _Ty>
    struct _Is_nonbool_integral_t : bool_constant<is_integral<_Ty>::value && !is_same<remove_cv_t<_Ty>, bool>::value>
    {
    };
    template <bool>
    struct _Select
    { // Select between aliases that extract either their first or second parameter
        template <class _Ty1, class>
        using _Apply = _Ty1;
    };

    template <>
    struct _Select<false>
    {
        template <class, class _Ty2>
        using _Apply = _Ty2;
    };
// 898
// 934
// VC not well implemented, switch to LLVM implementation
#include "__type_traits/is_nothrow_constructible.h"
    // 942
    // 953
    // VC not well implemented, switch to EbolaChan's personal implementation based on LLVM is_nothrow_constructible
    template <class _Ty>
    struct is_nothrow_default_constructible : is_nothrow_constructible<_Ty>
    {
        // determine whether value-initialization of _Ty is both valid and not potentially-throwing
    };
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on LLVM is_nothrow_constructible_v
    template <class _Ty>
    _INLINE_VAR constexpr bool is_nothrow_default_constructible_v = is_nothrow_constructible_v<_Ty>;
#endif
// VC not well implemented, switch to LLVM implementation
#include "__type_traits/is_nothrow_move_constructible.h"

    // Can't be implemented without compiler builtins. Fallback to is_assginable as an approximate.
    template <class _To, class _From>
    struct is_nothrow_assignable : is_assignable<_To, _From>
    {
        // determine whether assignment of _From to _To is both valid and not potentially-throwing
    };
#if _HAS_CXX14
    // Can't be implemented without compiler builtins. Fallback to is_assginable_v as an approximate.
    template <class _To, class _From>
    _INLINE_VAR constexpr bool is_nothrow_assignable_v = is_assignable_v<_To, _From>;
#endif
// 983
// 987
// VC not well implemented, switch to boost implementation
#include "__type_traits/is_nothrow_move_assignable.hpp"
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_nothrow_move_assignable
    template <class _Ty>
    _INLINE_VAR constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Ty>::value;
#endif
    // 995
    // 1090
    template <size_t>
    struct _Make_unsigned2; // Choose make_unsigned strategy by type size

    template <>
    struct _Make_unsigned2<1>
    {
        template <class>
        using _Apply = unsigned char;
    };

    template <>
    struct _Make_unsigned2<2>
    {
        template <class>
        using _Apply = unsigned short;
    };

    template <>
    struct _Make_unsigned2<4>
    {
        template <class _Ty>
        using _Apply = // assumes LLP64
            typename _Select<is_same<_Ty, long>::value || is_same<_Ty, unsigned long>::value>::template _Apply<unsigned long,
                                                                                                               unsigned int>;
    };

    template <>
    struct _Make_unsigned2<8>
    {
        template <class>
        using _Apply = unsigned long long;
    };

    template <class _Ty>
    using _Make_unsigned1 = // unsigned partner to cv-unqualified _Ty
        typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

    template <class _Ty>
    struct make_unsigned
    { // unsigned partner to _Ty
        static_assert(_Is_nonbool_integral_t<_Ty>::value || is_enum<_Ty>::value,
                      "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
                      "integral type or enumeration but not a bool type.");

        using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
    };
#endif
    template <class _Ty>
    using make_unsigned_t = typename make_unsigned<_Ty>::type;
#ifdef ARDUINO_ARCH_AVR
    template <class _Rep>
    constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val)
    { // makes _Val unsigned
        return static_cast<make_unsigned_t<_Rep>>(_Val);
    }
// 1140
// 1276
#if _HAS_CXX14
    template <class _Ty, unsigned int _Ix = 0>
    _INLINE_VAR constexpr size_t extent_v = 0; // determine extent of dimension _Ix of array _Ty

    template <class _Ty, size_t _Nx>
    _INLINE_VAR constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

    template <class _Ty, unsigned int _Ix, size_t _Nx>
    _INLINE_VAR constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

    template <class _Ty, unsigned int _Ix>
    _INLINE_VAR constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;
#endif
    template <class _Ty, unsigned int _Ix = 0>
    struct extent
    {
        static constexpr size_t value = 0; // determine extent of dimension _Ix of array _Ty
    };
    template <class _Ty, size_t _Nx>
    struct extent<_Ty[_Nx], 0>
    {
        static constexpr size_t value = _Nx;
    };
    template <class _Ty, unsigned int _Ix, size_t _Nx>
    struct extent<_Ty[_Nx], _Ix> : extent<_Ty, _Ix - 1>
    {
    };

    template <class _Ty, unsigned int _Ix>
    struct extent<_Ty[], _Ix> : extent<_Ty, _Ix - 1>
    {
    };

    template <class _Base, class _Derived>
    struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)>
    {
        // determine whether _Base is a base of or the same as _Derived
    };
#if _HAS_CXX14
    template <class _Base, class _Derived>
    _INLINE_VAR constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
#endif
    template <class _Ty>
    struct decay
    { // determines decayed version of _Ty
        using _Ty1 = remove_reference_t<_Ty>;
        using _Ty2 = typename _Select<is_function<_Ty1>::value>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
        using type = typename _Select<is_array<_Ty1>::value>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
    };
#endif
    template <class _Ty>
    using decay_t = typename decay<_Ty>::type;
#ifdef ARDUINO_ARCH_AVR
    template <class _Ty1, class _Ty2>
    using _Conditional_type = decltype(false ? _STD declval<_Ty1>() : _STD declval<_Ty2>());

#if _HAS_CXX20
    template <class _Ty1, class _Ty2, class = void>
    struct _Const_lvalue_cond_oper
    {
    };

    // N4810 [meta.trans.other]/3.3.4 (per the proposed resolution of LWG-3205): "Otherwise, if remove_cvref_t</**/> denotes
    // a type..."
    template <class _Ty1, class _Ty2>
    struct _Const_lvalue_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<const _Ty1 &, const _Ty2 &>>>
    {
        using type = remove_cvref_t<_Conditional_type<const _Ty1 &, const _Ty2 &>>;
    };

    template <class _Ty1, class _Ty2, class = void>
    struct _Decayed_cond_oper : _Const_lvalue_cond_oper<_Ty1, _Ty2>
    {
    };
#else  // ^^^ >= C++20 / <= C++17 vvv
    template <class _Ty1, class _Ty2, class = void>
    struct _Decayed_cond_oper
    {
    };
#endif // _HAS_CXX20

    template <class _Ty1, class _Ty2>
    struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>>
    {
        using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
    };

    template <class... _Ty>
    struct common_type;

    template <class... _Ty>
    using common_type_t = typename common_type<_Ty...>::type;

    template <>
    struct common_type<>
    {
    };

    template <class _Ty1>
    struct common_type<_Ty1> : common_type<_Ty1, _Ty1>
    {
    };

    template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
    struct _Common_type2 : common_type<_Decayed1, _Decayed2>
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2>
    {
    };

    template <class _Ty1, class _Ty2>
    struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2>
    {
    };

    template <class _Void, class _Ty1, class _Ty2, class... _Rest>
    struct _Common_type3
    {
    };

    template <class _Ty1, class _Ty2, class... _Rest>
    struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
        : common_type<common_type_t<_Ty1, _Ty2>, _Rest...>
    {
    };

    template <class _Ty1, class _Ty2, class... _Rest>
    struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...>
    {
    };

    template <class _Ty>
    _Ty _Returns_exactly() noexcept; // not defined

#if _HAS_CXX20
    _EXPORT_STD template <class, class, template <class> class, template <class> class>
    struct basic_common_reference
    {
    };

    template <class _From>
    struct _Copy_cv_impl
    {
        template <class _To>
        using _Apply = _To;
    };
    template <class _From>
    struct _Copy_cv_impl<const _From>
    {
        template <class _To>
        using _Apply = const _To;
    };
    template <class _From>
    struct _Copy_cv_impl<volatile _From>
    {
        template <class _To>
        using _Apply = volatile _To;
    };
    template <class _From>
    struct _Copy_cv_impl<const volatile _From>
    {
        template <class _To>
        using _Apply = const volatile _To;
    };
    template <class _From, class _To>
    using _Copy_cv = // N4950 [meta.trans.other]/2.3
        _Copy_cv_impl<_From>::template _Apply<_To>;

    template <class _Ty1>
    struct _Add_qualifiers
    { // _Add_qualifiers<A>::template _Apply is XREF(A) from N4950 [meta.trans.other]/2.2
        template <class _Ty2>
        using _Apply = _Copy_cv<_Ty1, _Ty2>;
    };
    template <class _Ty1>
    struct _Add_qualifiers<_Ty1 &>
    {
        template <class _Ty2>
        using _Apply = add_lvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
    };
    template <class _Ty1>
    struct _Add_qualifiers<_Ty1 &&>
    {
        template <class _Ty2>
        using _Apply = add_rvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
    };

#if !defined(__EDG__) && !defined(__clang__) // TRANSITION, DevCom-10095944
    template <class _Ty1, class _Ty2>
    using _Cond_res_if_right = // N4950 [meta.trans.other]/2.4
        decltype(false ? _Returns_exactly<_Ty1>() : _Returns_exactly<_Ty2>());

    template <class _Ty>
    using _Is_scalar_or_array = disjunction<is_scalar<_Ty>, is_array<_Ty>>;

    template <class _Ty1, class _Ty2, class = void>
    struct _Cond_res_workaround
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Cond_res_workaround<_Ty1, _Ty2, void_t<_Cond_res_if_right<_Ty1, _Ty2>>>
    {
        using _Uty = remove_cvref_t<_Ty1>;
        using type = conditional_t<conjunction_v<is_same<_Uty, remove_cvref_t<_Ty2>>, _Is_scalar_or_array<_Uty>,
                                                 disjunction<conjunction<is_lvalue_reference<_Ty1>, is_rvalue_reference<_Ty2>>,
                                                             conjunction<is_rvalue_reference<_Ty1>, is_lvalue_reference<_Ty2>>>>,
                                   decay_t<_Copy_cv<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>>, _Cond_res_if_right<_Ty1, _Ty2>>;
    };

    template <class _Ty1, class _Ty2>
    using _Cond_res = _Cond_res_workaround<_Ty1, _Ty2>::type;
#else  // ^^^ workaround / no workaround vvv
    template <class _Ty1, class _Ty2>
    using _Cond_res = // N4950 [meta.trans.other]/2.4
        decltype(false ? _Returns_exactly<_Ty1>() : _Returns_exactly<_Ty2>());
#endif // ^^^ no workaround ^^^

    _EXPORT_STD template <class...>
    struct common_reference;

    _EXPORT_STD template <class... _Types>
    using common_reference_t = common_reference<_Types...>::type;

    // N4950 [meta.trans.other]/5.1: "If sizeof...(T) is zero ..."
    template <>
    struct common_reference<>
    {
    };

    // N4950 [meta.trans.other]/5.2: "...if sizeof...(T) is one ..."
    template <class _Ty>
    struct common_reference<_Ty>
    {
        using type = _Ty;
    };

    // N4950 [meta.trans.other]/5.3: "...if sizeof...(T) is two..."

    // N4950 [meta.trans.other]/5.3.4: "if common_type_t<T1, T2> is well-formed..."
    // N4950 [meta.trans.other]/5.3.5: "Otherwise, there shall be no member type."
    template <class _Ty1, class _Ty2, class = void>
    struct _Common_reference2C : common_type<_Ty1, _Ty2>
    {
    };

    // N4950 [meta.trans.other]/5.3.3: "if COND_RES(T1, T2) is well-formed..."
    template <class _Ty1, class _Ty2>
    struct _Common_reference2C<_Ty1, _Ty2, void_t<_Cond_res<_Ty1, _Ty2>>>
    {
        using type = _Cond_res<_Ty1, _Ty2>;
    };

    // N4950 [meta.trans.other]/5.3.2: "if basic_common_reference<[...]>::type is well-formed..."
    template <class _Ty1, class _Ty2>
    using _Basic_specialization = basic_common_reference<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>,
                                                         _Add_qualifiers<_Ty1>::template _Apply, _Add_qualifiers<_Ty2>::template _Apply>::type;

    template <class _Ty1, class _Ty2, class = void>
    struct _Common_reference2B : _Common_reference2C<_Ty1, _Ty2>
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Common_reference2B<_Ty1, _Ty2, void_t<_Basic_specialization<_Ty1, _Ty2>>>
    {
        using type = _Basic_specialization<_Ty1, _Ty2>;
    };

    // N4950 [meta.trans.other]/5.3.1: "Let R be COMMON-REF(T1, T2). If T1 and T2 are reference types, R is well-formed, and
    // is_convertible_v<add_pointer_t<T1>, add_pointer_t<R>> && is_convertible_v<add_pointer_t<T2>, add_pointer_t<R>> is
    // true, then the member typedef type denotes R."
    template <class _Ty1, class _Ty2, class = void>
    struct _Common_reference2A : _Common_reference2B<_Ty1, _Ty2>
    {
    };

    template <class _Ty1, class _Ty2, class _Result = _Cond_res<_Copy_cv<_Ty1, _Ty2> &, _Copy_cv<_Ty2, _Ty1> &>,
              enable_if_t<is_lvalue_reference_v<_Result>, int> = 0>
    using _LL_common_ref = _Result;

    template <class _Ty1, class _Ty2, class = void>
    struct _Common_reference2AX
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Common_reference2AX<_Ty1 &, _Ty2 &, void_t<_LL_common_ref<_Ty1, _Ty2>>>
    {
        using type = _LL_common_ref<_Ty1, _Ty2>; // "both lvalues" case from N4950 [meta.trans.other]/2.5
    };

    template <class _Ty1, class _Ty2>
    struct _Common_reference2AX<_Ty1 &&, _Ty2 &, enable_if_t<is_convertible_v<_Ty1 &&, _LL_common_ref<const _Ty1, _Ty2>>>>
    {
        using type = _LL_common_ref<const _Ty1, _Ty2>; // "rvalue and lvalue" case from N4950 [meta.trans.other]/2.7
    };

    template <class _Ty1, class _Ty2>
    struct _Common_reference2AX<_Ty1 &, _Ty2 &&, enable_if_t<is_convertible_v<_Ty2 &&, _LL_common_ref<const _Ty2, _Ty1>>>>
    {
        using type = _LL_common_ref<const _Ty2, _Ty1>; // "lvalue and rvalue" case from N4950 [meta.trans.other]/2.8
    };

    template <class _Ty1, class _Ty2>
    using _RR_common_ref = remove_reference_t<_LL_common_ref<_Ty1, _Ty2>> &&;

    template <class _Ty1, class _Ty2>
    struct _Common_reference2AX<_Ty1 &&, _Ty2 &&,
                                enable_if_t<is_convertible_v<_Ty1 &&, _RR_common_ref<_Ty1, _Ty2>> && is_convertible_v<_Ty2 &&, _RR_common_ref<_Ty1, _Ty2>>>>
    {
        using type = _RR_common_ref<_Ty1, _Ty2>; // "both rvalues" case from N4950 [meta.trans.other]/2.6
    };

    template <class _Ty1, class _Ty2>
    using _Common_ref_2AX_t = _Common_reference2AX<_Ty1, _Ty2>::type;

    template <class _Ty1, class _Ty2>
    struct _Common_reference2A<_Ty1, _Ty2,
                               enable_if_t<is_convertible_v<add_pointer_t<_Ty1>, add_pointer_t<_Common_ref_2AX_t<_Ty1, _Ty2>>> && is_convertible_v<add_pointer_t<_Ty2>, add_pointer_t<_Common_ref_2AX_t<_Ty1, _Ty2>>>>>
    {
        using type = _Common_ref_2AX_t<_Ty1, _Ty2>;
    };

    template <class _Ty1, class _Ty2>
    struct common_reference<_Ty1, _Ty2> : _Common_reference2A<_Ty1, _Ty2>
    {
    };

    // N4950 [meta.trans.other]/5.4: "if sizeof...(T) is greater than two..."
    template <class _Void, class _Ty1, class _Ty2, class... _Types>
    struct _Fold_common_reference
    {
    };
    template <class _Ty1, class _Ty2, class... _Types>
    struct _Fold_common_reference<void_t<common_reference_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Types...>
        : common_reference<common_reference_t<_Ty1, _Ty2>, _Types...>
    {
    };

    template <class _Ty1, class _Ty2, class _Ty3, class... _Rest>
    struct common_reference<_Ty1, _Ty2, _Ty3, _Rest...> : _Fold_common_reference<void, _Ty1, _Ty2, _Ty3, _Rest...>
    {
    };

    _EXPORT_STD template <class _Ty>
    struct type_identity
    {
        using type = _Ty;
    };
    _EXPORT_STD template <class _Ty>
    using type_identity_t = type_identity<_Ty>::type;
#endif // _HAS_CXX20
#if _HAS_CXX14
    template <class _Type, template <class...> class _Template>
    _INLINE_VAR constexpr bool _Is_specialization_v = false; // true if and only if _Type is a specialization of _Template
    template <template <class...> class _Template, class... _Types>
    _INLINE_VAR constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;
#endif
    template <class _Type, template <class...> class _Template>
    struct _Is_specialization
    {
        static constexpr bool value = false; // true if and only if _Type is a specialization of _Template
    };
    template <template <class...> class _Template, class... _Types>
    struct _Is_specialization<_Template<_Types...>, _Template>
    {
        static constexpr bool value = true;
    };

    _EXPORT_STD template <class _Ty>
    _NODISCARD _MSVC_INTRINSIC constexpr _Ty &&forward(remove_reference_t<_Ty> &_Arg) noexcept
    {
        return static_cast<_Ty &&>(_Arg);
    }

    _EXPORT_STD template <class _Ty>
    _NODISCARD _MSVC_INTRINSIC constexpr _Ty &&forward(remove_reference_t<_Ty> &&_Arg) noexcept
    {
        static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
        return static_cast<_Ty &&>(_Arg);
    }

    _EXPORT_STD template <class _Ty>
    _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty> &&move(_Ty &&_Arg) noexcept
    {
        return static_cast<remove_reference_t<_Ty> &&>(_Arg);
    }
// 1576
#pragma warning(push)
#pragma warning(disable : 5215) // '%s' a function parameter with a volatile qualified type is deprecated in C++20
#pragma warning(disable : 5216) // '%s' a volatile qualified return type is deprecated in C++20

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-volatile"
#endif // defined(__clang__)

    template <class _Ty>
    _NODISCARD _Ty _Fake_copy_init(_Ty) noexcept;
    // _Fake_copy_init<T>(E):
    // (1) has type T [decay_t<decltype((E))> if T is deduced],
    // (2) is well-formed if and only if E is implicitly convertible to T and T is destructible, and
    // (3) is non-throwing if and only if both conversion from decltype((E)) to T and destruction of T are non-throwing.

#ifdef __clang__
#pragma clang diagnostic pop
#endif // defined(__clang__)

#pragma warning(pop)

    _EXPORT_STD template <class _Ty>
    class reference_wrapper;

    // std::invoke isn't constexpr in C++17, and normally implementers are forbidden from "strengthening" constexpr
    // (N4950 [constexpr.functions]/1), yet both std::apply and std::visit are required to be constexpr and have
    // invoke-like behavior. As a result, we've chosen to apply the part of P1065R2 resolving LWG-2894 as a defect report.

    enum class _Invoker_strategy
    {
        _Functor,
        _Pmf_object,
        _Pmf_refwrap,
        _Pmf_pointer,
        _Pmd_object,
        _Pmd_refwrap,
        _Pmd_pointer
    };

    struct _Invoker_functor
    {
        static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;

        template <class _Callable, class... _Types>
        static constexpr auto _Call(_Callable &&_Obj, _Types &&..._Args) noexcept(
            noexcept(static_cast<_Callable &&>(_Obj)(static_cast<_Types &&>(_Args)...)))
            -> decltype(static_cast<_Callable &&>(_Obj)(static_cast<_Types &&>(_Args)...))
        {
            return static_cast<_Callable &&>(_Obj)(static_cast<_Types &&>(_Args)...);
        }
    };

    struct _Invoker_pmf_object
    {
        static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;

        template <class _Decayed, class _Ty1, class... _Types2>
        static constexpr auto _Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(
            noexcept((static_cast<_Ty1 &&>(_Arg1).*_Pmf)(static_cast<_Types2 &&>(_Args2)...)))
            -> decltype((static_cast<_Ty1 &&>(_Arg1).*_Pmf)(static_cast<_Types2 &&>(_Args2)...))
        {
            return (static_cast<_Ty1 &&>(_Arg1).*_Pmf)(static_cast<_Types2 &&>(_Args2)...);
        }
    };

    struct _Invoker_pmf_refwrap
    {
        static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;

        template <class _Decayed, class _Refwrap, class... _Types2>
        static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2 &&..._Args2) noexcept(
            noexcept((_Rw.get().*_Pmf)(static_cast<_Types2 &&>(_Args2)...)))
            -> decltype((_Rw.get().*_Pmf)(static_cast<_Types2 &&>(_Args2)...))
        {
            return (_Rw.get().*_Pmf)(static_cast<_Types2 &&>(_Args2)...);
        }
    };

    struct _Invoker_pmf_pointer
    {
        static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;

        template <class _Decayed, class _Ty1, class... _Types2>
        static constexpr auto _Call(_Decayed _Pmf, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(
            noexcept(((*static_cast<_Ty1 &&>(_Arg1)).*_Pmf)(static_cast<_Types2 &&>(_Args2)...)))
            -> decltype(((*static_cast<_Ty1 &&>(_Arg1)).*_Pmf)(static_cast<_Types2 &&>(_Args2)...))
        {
            return ((*static_cast<_Ty1 &&>(_Arg1)).*_Pmf)(static_cast<_Types2 &&>(_Args2)...);
        }
    };

    struct _Invoker_pmd_object
    {
        static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;

        template <class _Decayed, class _Ty1>
        static constexpr auto _Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept -> decltype(static_cast<_Ty1 &&>(_Arg1).*_Pmd)
        {
            return static_cast<_Ty1 &&>(_Arg1).*_Pmd;
        }
    };

    struct _Invoker_pmd_refwrap
    {
        static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;

        template <class _Decayed, class _Refwrap>
        static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -> decltype(_Rw.get().*_Pmd)
        {
            return _Rw.get().*_Pmd;
        }
    };

    struct _Invoker_pmd_pointer
    {
        static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;

        template <class _Decayed, class _Ty1>
        static constexpr auto _Call(_Decayed _Pmd, _Ty1 &&_Arg1) noexcept(noexcept((*static_cast<_Ty1 &&>(_Arg1)).*_Pmd))
            -> decltype((*static_cast<_Ty1 &&>(_Arg1)).*_Pmd)
        {
            return (*static_cast<_Ty1 &&>(_Arg1)).*_Pmd;
        }
    };

    template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>,
              bool _Is_pmf = _STRUCT14VALUE_V(is_member_function_pointer, _Removed_cvref),
              bool _Is_pmd = _STRUCT14VALUE_V(is_member_object_pointer, _Removed_cvref)>
    struct _Invoker1;

    template <class _Callable, class _Ty1, class _Removed_cvref>
    struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
        : conditional_t<_STRUCT14VALUE_V(is_same, typename _Is_memfunptr<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>) || _STRUCT14VALUE_V(is_base_of, typename _Is_memfunptr<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>),
                        _Invoker_pmf_object,
                        conditional_t<_STRUCT14VALUE_V(_Is_specialization, _Remove_cvref_t<_Ty1>, reference_wrapper), _Invoker_pmf_refwrap,
                                      _Invoker_pmf_pointer>>
    {
    }; // pointer to member function

    template <class _Callable, class _Ty1, class _Removed_cvref>
    struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
        : conditional_t<
              _STRUCT14VALUE_V(is_same, typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>) || _STRUCT14VALUE_V(is_base_of, typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>),
              _Invoker_pmd_object,
              conditional_t<_STRUCT14VALUE_V(_Is_specialization, _Remove_cvref_t<_Ty1>, reference_wrapper), _Invoker_pmd_refwrap,
                            _Invoker_pmd_pointer>>
    {
    }; // pointer to member data

    template <class _Callable, class _Ty1, class _Removed_cvref>
    struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor
    {
    };

    _EXPORT_STD template <class _Callable>
    _CONSTEXPR17 auto invoke(_Callable &&_Obj) noexcept(noexcept(static_cast<_Callable &&>(_Obj)()))
        -> decltype(static_cast<_Callable &&>(_Obj)())
    {
        return static_cast<_Callable &&>(_Obj)();
    }

    _EXPORT_STD template <class _Callable, class _Ty1, class... _Types2>
    _CONSTEXPR17 auto invoke(_Callable &&_Obj, _Ty1 &&_Arg1, _Types2 &&..._Args2) noexcept(
        noexcept(_Invoker1<_Callable, _Ty1>::_Call(
            static_cast<_Callable &&>(_Obj), static_cast<_Ty1 &&>(_Arg1), static_cast<_Types2 &&>(_Args2)...)))
        -> decltype(_Invoker1<_Callable, _Ty1>::_Call(
            static_cast<_Callable &&>(_Obj), static_cast<_Ty1 &&>(_Arg1), static_cast<_Types2 &&>(_Args2)...))
    {
        if _CONSTEXPR14 ()
            (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor)
            {
                return static_cast<_Callable &&>(_Obj)(static_cast<_Ty1 &&>(_Arg1), static_cast<_Types2 &&>(_Args2)...);
            }
        else if _CONSTEXPR14 ()
            (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object)
            {
                return (static_cast<_Ty1 &&>(_Arg1).*_Obj)(static_cast<_Types2 &&>(_Args2)...);
            }
        else if _CONSTEXPR14 ()
            (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap)
            {
                return (_Arg1.get().*_Obj)(static_cast<_Types2 &&>(_Args2)...);
            }
        else if _CONSTEXPR14 ()
            (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer)
            {
                return ((*static_cast<_Ty1 &&>(_Arg1)).*_Obj)(static_cast<_Types2 &&>(_Args2)...);
            }
        else if _CONSTEXPR14 ()
            (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object)
            {
                return static_cast<_Ty1 &&>(_Arg1).*_Obj;
            }
        else if _CONSTEXPR14 ()
            (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap)
            {
                return _Arg1.get().*_Obj;
            }
        else
        {
            _STL_INTERNAL_STATIC_ASSERT(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer);
            return (*static_cast<_Ty1 &&>(_Arg1)).*_Obj;
        }
    }
    // 1757
    // 1786
    template <class _From, class _To, class = void>
    struct _Invoke_convertible : false_type
    {
    };

    template <class _From, class _To>
    struct _Invoke_convertible<_From, _To, void_t<decltype(_STD _Fake_copy_init<_To>(_STD _Returns_exactly<_From>()))>>
        : true_type
    {
    };

    template <class _From, class _To>
    struct _Invoke_nothrow_convertible
        : bool_constant<noexcept(_STD _Fake_copy_init<_To>(_STD _Returns_exactly<_From>()))>
    {
    };

    template <class _Result, bool _Nothrow>
    struct _Invoke_traits_common
    {
        using type = _Result;
        using _Is_invocable = true_type;
        using _Is_nothrow_invocable = bool_constant<_Nothrow>;
        template <class _Rx>
        using _Is_invocable_r = bool_constant<_STRUCT14VALUE_V(disjunction, is_void<_Rx>, _Invoke_convertible<type, _Rx>)>;
        template <class _Rx>
        using _Is_nothrow_invocable_r = bool_constant<_STRUCT14VALUE_V(conjunction, _Is_nothrow_invocable, disjunction<is_void<_Rx>, conjunction<_Invoke_convertible<type, _Rx>, _Invoke_nothrow_convertible<type, _Rx>>>)>;
    };

    template <class _Void, class _Callable>
    struct _Invoke_traits_zero
    {
        // selected when _Callable isn't callable with zero _Args
        using _Is_invocable = false_type;
        using _Is_nothrow_invocable = false_type;
        template <class _Rx>
        using _Is_invocable_r = false_type;
        template <class _Rx>
        using _Is_nothrow_invocable_r = false_type;
    };

    template <class _Callable>
    using _Decltype_invoke_zero = decltype(_STD declval<_Callable>()());

    template <class _Callable>
    struct _Invoke_traits_zero<void_t<_Decltype_invoke_zero<_Callable>>, _Callable>
        : _Invoke_traits_common<_Decltype_invoke_zero<_Callable>, noexcept(_STD declval<_Callable>()())>
    {
    };

    template <class _Void, class... _Types>
    struct _Invoke_traits_nonzero
    {
        // selected when _Callable isn't callable with nonzero _Args
        using _Is_invocable = false_type;
        using _Is_nothrow_invocable = false_type;
        template <class _Rx>
        using _Is_invocable_r = false_type;
        template <class _Rx>
        using _Is_nothrow_invocable_r = false_type;
    };

    template <class _Callable, class _Ty1, class... _Types2>
    using _Decltype_invoke_nonzero = decltype(_Invoker1<_Callable, _Ty1>::_Call(
        _STD declval<_Callable>(), _STD declval<_Ty1>(), _STD declval<_Types2>()...));

    template <class _Callable, class _Ty1, class... _Types2>
    struct _Invoke_traits_nonzero<void_t<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>>, _Callable, _Ty1,
                                  _Types2...> : _Invoke_traits_common<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>,
                                                                      noexcept(_Invoker1<_Callable, _Ty1>::_Call(
                                                                          _STD declval<_Callable>(), _STD declval<_Ty1>(), _STD declval<_Types2>()...))>
    {
    };

    template <class _Callable, class... _Args>
    using _Select_invoke_traits = conditional_t<sizeof...(_Args) == 0, _Invoke_traits_zero<void, _Callable>,
                                                _Invoke_traits_nonzero<void, _Callable, _Args...>>;
    // 1853
    //  1878
    template <class _Rx, class _Callable, class... _Args>
    using _Is_invocable_r_ = typename _Select_invoke_traits<_Callable, _Args...>::template _Is_invocable_r<_Rx>;

    template <class _Rx, class _Callable, class... _Args>
    struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...>
    {
        // determines whether _Callable is callable with _Args and return type _Rx
    };
    // 1886
    //   1947
    template <class _Ty>
    struct _Is_swappable;

    template <class _Ty>
    struct _Is_nothrow_swappable;

#if _HAS_CXX17
    template <class _Ty, enable_if_t<is_move_constructible_v<_Ty> && is_move_assignable_v<_Ty>, int> = 0>
#else  // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
    template <class _Ty, int _Enabled = 0>
#endif // _HAS_CXX17
    _CONSTEXPR20 void swap(_Ty &, _Ty &) noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value);

    template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
    _CONSTEXPR20 void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

    template <class _Ty1, class _Ty2, class = void>
    struct _Swappable_with_helper : false_type
    {
    }; // swap(declval<_Ty1>(), declval<_Ty2>()) is not valid

    template <class _Ty1, class _Ty2>
    struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(_STD declval<_Ty1>(), _STD declval<_Ty2>()))>>
        : true_type
    {
    }; // swap(declval<_Ty1>(), declval<_Ty2>()) is valid

    template <class _Ty1, class _Ty2>
    struct _Is_swappable_with
        : conjunction<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>
    {
        // Determine if expressions with type and value category _Ty1 and _Ty2 can be swapped (and vice versa)
    };

    template <class _Ty>
    struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type
    {
        // Determine if _Ty lvalues satisfy is_swappable_with
    };
    // 1981
#endif
}
#pragma GCC visibility pop