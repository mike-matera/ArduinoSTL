[रीडमी.ें.मद](README.en.md)

क्योंकि[मूल ArduinoSTL](https://github.com/mike-matera/ArduinoSTL)लेखक ने इसे लंबे समय तक अपडेट नहीं किया है (202203~202212)। मैंने इस शाखा को Arduino सार्वजनिक लाइब्रेरी में जारी किया और इसे अलग करने के लिए इसका नाम Cpp_Standard_Library रखा।

यह लाइब्रेरी Arduino पर C++11~17 मानक लाइब्रेरी (STL) के अधिकांश कार्यों को लागू करने का प्रयास करती है। ArduinoSTL के अलावा, इस लाइब्रेरी के कुछ फ़ंक्शन MSVC, LLVM और बूस्ट को भी संदर्भित करते हैं। क्योंकि इंटरफ़ेस एसटीएल पर आधारित है, इसलिए अतिरिक्त दस्तावेज़ लिखने की कोई आवश्यकता नहीं है। आप किसी भी आधिकारिक एसटीएल दस्तावेज़ का संदर्भ ले सकते हैं। जब तक अन्यथा न कहा जाए, इस लाइब्रेरी का उपयोग समान होना चाहिए। यदि यह भिन्न है, तो यह एक बग होना चाहिए। समस्या प्रस्तुत करने के लिए आपका स्वागत है।

यदि आपको कुछ फ़ंक्शंस की आवश्यकता है जो मानक लाइब्रेरी में हैं लेकिन इस लाइब्रेरी में प्रदान नहीं किए गए हैं, तो आपका एक अंक सबमिट करने के लिए भी स्वागत है, और लेखक पहले इसे आपके लिए लागू करेगा।

वर्तमान में समर्थित आर्किटेक्चर:

-   AVR के लिए C++17 की आवश्यकता है। बदलने की जरूरत`%LOCALAPPDATA%\Arduino15\packages\arduino\hardware\avr\*.*.*\platform.txt`तटस्थ`-std=gnu++11`के लिए`-std=gnu++17`
-   एसएएम को C++11 की आवश्यकता है
-   ESP32 के लिए C++17 की आवश्यकता है। बदलने की जरूरत`%LOCALAPPDATA%\Arduino15\packages\arduino\hardware\esp32\*.*.*\platform.txt`सभी में`-std=gnu++11`के लिए`-std=gnu++17`

किसी भी C++ मानक हेडर फ़ाइल को शामिल करने से पहले, आपको पहले शामिल करना होगा`Cpp_Standard_Library.h`. यह Arduino IDE के लिए एक संकेत है, जो कंपाइलर को बताता है कि इस लाइब्रेरी को संकलन प्रक्रिया में शामिल किया जाना चाहिए।

# हस्ताक्षर कार्य (इस तक सीमित नहीं)

-   `<algorithm> fill_n shuffle`
-   `<chrono> chrono::duration`
-   `<functional> std::function`
-   `<iostream> cin cout`मानक इनपुट और आउटपुट स्ट्रीम के रूप में सीरियल पोर्ट का उपयोग करें
-   `<map>`
-   `<memory> unique_ptr`
-   `<random> mt19937, ArduinoUrng`：`mt19937`यह बहुत अधिक मेमोरी (लगभग 5K) लेता है, इसलिए इसका उपयोग सावधानी से करें।`ArduinoUrng`Arduino प्लेटफ़ॉर्म विशिष्ट है`UniformRandomNumberGenerator`,के रूप में उपयोग किया जा सकता है`shuffle`, जो एक सॉफ्टवेयर छद्म-यादृच्छिक जनरेटर है और इसे एक यादृच्छिक बीज सेट करने की आवश्यकता है। ESP32 आर्किटेक्चर भी अतिरिक्त रूप से समर्थन करता है`EspUrng`, एक हार्डवेयर सच्चा यादृच्छिक जनरेटर है और बीज सेटिंग का समर्थन नहीं करता है।
-   `<ratio>`
-   `<set>`
-   `<type_traits>`
-   `<vector>`
-   `<xutility> std::begin std::end`
-   यदि कंपाइलर समान नाम के साथ कुछ मानक लाइब्रेरी फ़ंक्शन के साथ आता है, तो इसके साथ आने वाले संस्करण को प्राथमिकता दी जाएगी। कंपाइलर अन्य मानक लाइब्रेरी सुविधाओं के साथ शिप कर सकता है जो इस लाइब्रेरी द्वारा प्रदान नहीं की जाती हैं, और वे सुविधाएं इस लाइब्रेरी के साथ टकराव नहीं करती हैं।

# मूल README (केवल संदर्भ के लिए, कुछ सामग्री पुरानी हो चुकी है)

यह Arduino लाइब्रेरी के रूप में पैक की गई C++ मानक लाइब्रेरी का कार्यान्वयन है। लाइब्रेरी Arduino वातावरण में प्रमुख C++ सुविधाएँ जोड़कर मेरी CS-11M कक्षा को पढ़ाने में सहायता करती है।

लाइब्रेरी को uClibc++ से पोर्ट किया गया है:

[एचटीटीपी://गीत.ुक्लीब्स.ऑर्ग/ुक्लीब्स++](http://git.uclibc.org/uClibc++)

एंडी ब्राउन की Arduino लाइब्रेरी से स्ट्रीम कार्यान्वयन के साथ:

[एचटीटीपी://ैंडिबरौन.में.ुक/2011/01/15/थे-स्टैण्डर्ड-टेम्पलेट-लाइब्रेरी-सटल-फॉर-अवर-विथ-स-स्ट्रीम्स/](http://andybrown.me.uk/2011/01/15/the-standard-template-library-stl-for-avr-with-c-streams/)

## प्रिंटफ() और स्कैनएफ() का उपयोग करना

ArduinoSTL हेडर फ़ाइल में आपकी पसंद के सीरियल पोर्ट को बाइंड करने के लिए कोड होता है
stdio आदिम। यह स्वचालित रूप से होता है लेकिन उपयोगकर्ता को फिर भी कॉल करना होगा
सीरियल.शुरू()

```c++
#include <ArduinoSTL.h>

void setup() {
  Serial.begin(9600); 
  printf("Hello World\n");
}
```

## का उपयोग करते हुए`cin`एक`cout`

जब आप इस हेडर फ़ाइल को शामिल करते हैं तो आपको स्वचालित रूप से cin और cout के आधार पर प्राप्त होता है`Serial`. अपना स्वयं का उपकरण निर्दिष्ट करने के तरीके के लिए नीचे देखें। यहां एक उदाहरण स्केच का उपयोग किया गया है`cin`और`cout`.

```c++
#include <ArduinoSTL.h>

using namespace std;

void setup() {
  Serial.begin(9600);
  cout << "Feed me an integers." << endl;
}

void loop() {
  int foo;
  if (cin >> foo) { 
    cout << "You fed me " << foo << endl;
  }else{
    cin.clear();
    cin.ignore();
  }
}
```

## सीरियल पोर्ट बदलना

आप कौन सा सीरियल पोर्ट बदल सकते हैं`cin`,`cout`और`printf()`उपयोग। आप अंतर्निर्मित सीरियल पोर्ट का उपयोग कर सकते हैं (उदा.`Serial1`लियोनार्डो पर) या आप लागू करने वाले सॉफ़्टवेयर सीरियल पोर्ट का उपयोग कर सकते हैं`Stream`.

### बिल्ट-इन पोर्ट का उपयोग करना

में`src/ArduinoSTL.cpp`का मान बदलें`ARDUINOSTL_DEFAULT_SERIAL`. अन्य डिफ़ॉल्टों को टिप्पणी रहित छोड़ दें।

### सॉफ़्टवेयर सीरियल पोर्ट का उपयोग करना।

तय करना`ARDUINO_DEFAULT_SERAL`को`NULL`. अन्य चूकों पर टिप्पणी करें।

यहां एक उदाहरण स्केच है जो SofwareSerial का उपयोग करता है:

```c++
#include <ArduinoSTL.h>
#include <SoftwareSerial.h>

SoftwareSerial mySerial(0, 1);

namespace std { 
  ohserialstream cout(mySerial);
  ihserialstream cin(mySerial);
}

void setup() {
  mySerial.begin(9600);
  ArduinoSTL_Serial.connect(mySerial);
}
```

## के तात्कालिकरण से बचना`cin`और`cout`

टिप्पणी करना`ARDUINOSTL_DEFAULT_CIN_COUT`और कुछ भी तत्काल नहीं किया जाएगा. यदि आप एक गैर-डिफ़ॉल्ट सीरियल पोर्ट का चयन करना चाहते हैं तो आपको इस ध्वज पर टिप्पणी अवश्य करनी चाहिए। उपयोग के लिए कोई प्रशंसनीय ओवरहेड नहीं है`printf()`इसलिए आप फिलहाल इसे आरंभ करने से बच नहीं सकते।

## ज्ञात पहलु

फ़्लोट्स और डबल्स का उपयोग करके मुद्रण`cout`प्रारूप विनिर्देशकों को अनदेखा करता है।

uClibc काफी हद तक पूर्ण प्रतीत होता है। Arduino के पास सीमित मात्रा में हीप उपलब्ध होने पर भी स्ट्रिंग और वेक्टर दोनों काम करते हैं। uClibc++ स्थिति पृष्ठ यहां पाया जा सकता है:

[हत्तपः://क्स्क्स.ुक्लीब्स.ऑर्ग/स्टेटस.हटम्ल](https://cxx.uclibc.org/status.html)

हमेशा नवीनतम Arduino IDE का उपयोग करें। यह लाइब्रेरी Arduino IDE लाइब्रेरी विशिष्टता rev.2.1 का उपयोग करती है, जिसमें केवल Arduino 1.6.10 और उच्चतर पर उपलब्ध सुविधाएँ हैं। विशिष्टता यहां पाई जा सकती है:

[हत्तपः://गिटहब.कॉम/ार्डुइनो/ार्डुइनो/विकी/ार्डुइनो-आईडीई-1.5:-लाइब्रेरी-स्पेसिफिकेशन](https://github.com/arduino/Arduino/wiki/Arduino-IDE-1.5:-Library-specification)

## लाइसेंस

uClibc++ लाइब्रेरी को LGPL के अंतर्गत लाइसेंस प्राप्त है। यह प्रोजेक्ट अपने द्वारा उपयोग किए जाने वाले अधिकांश कोड के साथ संगत होने के लिए एलजीपीएल को अपनाता है। जब तक अन्यथा उल्लेख न किया गया हो, सभी कोड LGPL के अंतर्गत लाइसेंसीकृत हैं। एक अपवाद है:

-   यहां एंडी ब्राउन की इच्छा के अनुसार src/serstream को BSD लाइसेंस के तहत लाइसेंस दिया गया है:[एचटीटीपी://ैंडिबरौन.में.ुक/टर्म्स-एंड-कंडीशंस/](http://andybrown.me.uk/terms-and-conditions/)
