[रीडमी.ें.मद](README.en.md)

क्योंकि[मूल ArduinoSTL](https://github.com/mike-matera/ArduinoSTL)लेखक ने इसे लंबे समय तक अपडेट नहीं किया है (202203~202212)। मैंने इस शाखा को Arduino सार्वजनिक लाइब्रेरी में जारी किया और इसे अलग करने के लिए इसका नाम Cpp_Standard_Library रखा।

यह लाइब्रेरी Arduino पर C++11~17 मानक लाइब्रेरी (STL) के अधिकांश कार्यों को लागू करने का प्रयास करती है। ArduinoSTL के अलावा, इस लाइब्रेरी के कुछ फ़ंक्शन MSVC, LLVM, बूस्ट और GCC को भी संदर्भित करते हैं। क्योंकि इंटरफ़ेस एसटीएल पर आधारित है, इसलिए अतिरिक्त दस्तावेज़ लिखने की कोई आवश्यकता नहीं है। आप किसी भी आधिकारिक एसटीएल दस्तावेज़ का संदर्भ ले सकते हैं। जब तक अन्यथा न कहा जाए, इस लाइब्रेरी का उपयोग समान होना चाहिए। यदि यह भिन्न है, तो यह एक बग होना चाहिए। समस्या प्रस्तुत करने के लिए आपका स्वागत है।

यदि आपको कुछ फ़ंक्शंस की आवश्यकता है जो मानक लाइब्रेरी में हैं लेकिन इस लाइब्रेरी में प्रदान नहीं किए गए हैं, तो आपका एक अंक सबमिट करने के लिए भी स्वागत है, और लेखक पहले इसे आपके लिए लागू करेगा।

निम्नलिखित आर्किटेक्चर समर्थित हैं लेकिन अतिरिक्त कॉन्फ़िगरेशन की आवश्यकता है:

-   AVR के लिए C++17 की आवश्यकता है। बदलने की जरूरत`%LOCALAPPDATA%\Arduino15\packages\arduino\hardware\avr\*.*.*\platform.txt`तटस्थ`-std=gnu++11`के लिए`-std=gnu++17`
-   एसएएम को C++11 की आवश्यकता है। में होना आवश्यक है`%LOCALAPPDATA%\Arduino15\packages\arduino\hardware\sam\*.*.*\platform.txt`तटस्थ`compiler.cpp.flags`जोड़ें`-fpermissive`बैनर
-   ESP32 के लिए C++17 की आवश्यकता है। बदलने की जरूरत`%LOCALAPPDATA%\Arduino15\packages\arduino\hardware\esp32\*.*.*\platform.txt`सभी में`-std=gnu++11`के लिए`-std=gnu++17`, और में`compiler.cpp.flags`जोड़ें`-fpermissive`बैनर

किसी भी C++ मानक हेडर फ़ाइल को शामिल करने से पहले, आपको पहले शामिल करना होगा`Cpp_Standard_Library.h`. यह Arduino IDE के लिए एक संकेत है, जो कंपाइलर को बताता है कि इस लाइब्रेरी को संकलन प्रक्रिया में शामिल किया जाना चाहिए।

# हस्ताक्षर कार्य (इस तक सीमित नहीं)

-   `<algorithm> fill_n shuffle`
-   `<chrono> chrono::duration`
-   `<dynarray>`एक बार इसके C++ मानक में प्रवेश की उम्मीद थी। हालाँकि मैं अंत में प्रवेश करने में सक्षम नहीं था, एक के रूप में`array`और`vector`मध्यवर्ती प्रकार बहुत उपयोगी होते हैं।
-   `<functional> std::function`गैर-मानक व्यवहार: किसी अशक्त वस्तु पर बुलाए जाने पर कुछ भी नहीं करना। ऐसा इसलिए है क्योंकि मानक व्यवहार यह है कि एक अपवाद फेंक दिया जाना चाहिए, लेकिन Arduino अपवादों का समर्थन नहीं करता है। यदि आप किसी शून्य ऑब्जेक्ट को कॉल करते समय कुछ नहीं करना चाहते हैं, तो आप यह जांचे बिना कि ऑब्जेक्ट शून्य है या नहीं, इसे सीधे कॉल कर सकते हैं।
-   `<iostream> cin cout endl`उपयोग`Serial`मानक इनपुट और आउटपुट स्ट्रीम लागू करें। हालाँकि, आपको अभी भी मैन्युअल रूप से करना होगा`Serial.begin`. में नहीं होना चाहिए`setup`फ़ंक्शन से पहले वैश्विक चर आरंभीकरण चरण में उपयोग किया जाता है`Serial`,क्योंकि`setup`बुलाए जाने से पहले कोई गारंटी नहीं है`Serial`आरंभीकरण पूरा हो गया है, इस समय का उपयोग करें`Serial`अपरिभाषित व्यवहार है. इसके अलावा, परीक्षण में पाया गया कि एसएएम आर्किटेक्चर के लिए, सीरियल पोर्ट आरंभीकरण के तुरंत बाद कुछ यादृच्छिक बाइट्स भेज सकता है। यह एक हार्डवेयर डिज़ाइन दोष प्रतीत होता है जिसे सॉफ़्टवेयर स्तर पर हल नहीं किया जा सकता है। प्राप्तकर्ता को इस मुद्दे को ध्यान में रखना चाहिए .
-   `<map>`
-   `<memory> unique_ptr make_unique`
-   `<random>`，`mt19937`यह बहुत अधिक मेमोरी (लगभग 5K) लेता है, इसलिए इसका उपयोग सावधानी से करें।`ArduinoUrng`Arduino प्लेटफ़ॉर्म विशिष्ट है`UniformRandomNumberGenerator`,के रूप में उपयोग किया जा सकता है`shuffle`, जो एक सॉफ्टवेयर छद्म-यादृच्छिक जनरेटर है और इसे एक यादृच्छिक बीज सेट करने की आवश्यकता है। ESP32 आर्किटेक्चर भी अतिरिक्त रूप से समर्थन करता है`EspUrng`, एक हार्डवेयर सच्चा यादृच्छिक जनरेटर है और बीज सेटिंग का समर्थन नहीं करता है।
-   `<ratio>`
-   `<set>`
-   `<type_traits>`
-   `<vector>`
-   `std::begin std::end`
-   यदि कंपाइलर समान नाम के साथ कुछ मानक लाइब्रेरी फ़ंक्शन के साथ आता है, तो इसके साथ आने वाले संस्करण को प्राथमिकता दी जाएगी। कंपाइलर अन्य मानक लाइब्रेरी सुविधाओं के साथ शिप कर सकता है जो इस लाइब्रेरी द्वारा प्रदान नहीं की जाती हैं, और वे सुविधाएं इस लाइब्रेरी के साथ टकराव नहीं करती हैं।

स्थापना के बाद नमूना प्रोजेक्ट की जांच करना याद रखें!

# मूल README (केवल संदर्भ के लिए, कुछ सामग्री पुरानी हो चुकी है)

यह Arduino लाइब्रेरी के रूप में पैक की गई C++ मानक लाइब्रेरी का कार्यान्वयन है। लाइब्रेरी Arduino वातावरण में प्रमुख C++ सुविधाएँ जोड़कर मेरी CS-11M कक्षा को पढ़ाने में सहायता करती है।

लाइब्रेरी को uClibc++ से पोर्ट किया गया है:

[एचटीटीपी://गीत.ुक्लीब्स.ऑर्ग/ुक्लीब्स++](http://git.uclibc.org/uClibc++)

एंडी ब्राउन की Arduino लाइब्रेरी से स्ट्रीम कार्यान्वयन के साथ:

[एचटीटीपी://ैंडिबरौन.में.ुक/2011/01/15/थे-स्टैण्डर्ड-टेम्पलेट-लाइब्रेरी-सटल-फॉर-अवर-विथ-स-स्ट्रीम्स/](http://andybrown.me.uk/2011/01/15/the-standard-template-library-stl-for-avr-with-c-streams/)

## प्रिंटफ() और स्कैनएफ() का उपयोग करना

ArduinoSTL हेडर फ़ाइल में आपकी पसंद के सीरियल पोर्ट को बाइंड करने के लिए कोड होता है
stdio आदिम। यह स्वचालित रूप से होता है लेकिन उपयोगकर्ता को फिर भी कॉल करना होगा
सीरियल.शुरू()

```c++
#include <ArduinoSTL.h>

void setup() {
  Serial.begin(9600); 
  printf("Hello World\n");
}
```

## का उपयोग करते हुए`cin`एक`cout`

जब आप इस हेडर फ़ाइल को शामिल करते हैं तो आपको स्वचालित रूप से cin और cout के आधार पर प्राप्त होता है`Serial`. अपना स्वयं का उपकरण निर्दिष्ट करने के तरीके के लिए नीचे देखें। यहां एक उदाहरण स्केच का उपयोग किया गया है`cin`और`cout`.

```c++
#include <ArduinoSTL.h>

using namespace std;

void setup() {
  Serial.begin(9600);
  cout << "Feed me an integers." << endl;
}

void loop() {
  int foo;
  if (cin >> foo) { 
    cout << "You fed me " << foo << endl;
  }else{
    cin.clear();
    cin.ignore();
  }
}
```

## सीरियल पोर्ट बदलना

आप कौन सा सीरियल पोर्ट बदल सकते हैं`cin`,`cout`और`printf()`उपयोग। आप अंतर्निर्मित सीरियल पोर्ट का उपयोग कर सकते हैं (उदा.`Serial1`लियोनार्डो पर) या आप लागू करने वाले सॉफ़्टवेयर सीरियल पोर्ट का उपयोग कर सकते हैं`Stream`.

### बिल्ट-इन पोर्ट का उपयोग करना

में`src/ArduinoSTL.cpp`का मान बदलें`ARDUINOSTL_DEFAULT_SERIAL`. अन्य डिफ़ॉल्टों को टिप्पणी रहित छोड़ दें।

### सॉफ़्टवेयर सीरियल पोर्ट का उपयोग करना।

तय करना`ARDUINO_DEFAULT_SERAL`को`NULL`. अन्य चूकों पर टिप्पणी करें।

यहां एक उदाहरण स्केच है जो SofwareSerial का उपयोग करता है:

```c++
#include <ArduinoSTL.h>
#include <SoftwareSerial.h>

SoftwareSerial mySerial(0, 1);

namespace std { 
  ohserialstream cout(mySerial);
  ihserialstream cin(mySerial);
}

void setup() {
  mySerial.begin(9600);
  ArduinoSTL_Serial.connect(mySerial);
}
```

## के तात्कालिकरण से बचना`cin`और`cout`

टिप्पणी करना`ARDUINOSTL_DEFAULT_CIN_COUT`और कुछ भी तत्काल नहीं किया जाएगा. यदि आप एक गैर-डिफ़ॉल्ट सीरियल पोर्ट का चयन करना चाहते हैं तो आपको इस ध्वज पर टिप्पणी अवश्य करनी चाहिए। उपयोग के लिए कोई प्रशंसनीय ओवरहेड नहीं है`printf()`इसलिए आप फिलहाल इसे आरंभ करने से बच नहीं सकते।

## ज्ञात पहलु

फ़्लोट्स और डबल्स का उपयोग करके मुद्रण`cout`प्रारूप विनिर्देशकों को अनदेखा करता है।

uClibc काफी हद तक पूर्ण प्रतीत होता है। Arduino के पास सीमित मात्रा में हीप उपलब्ध होने पर भी स्ट्रिंग और वेक्टर दोनों काम करते हैं। uClibc++ स्थिति पृष्ठ यहां पाया जा सकता है:

[हत्तपः://क्स्क्स.ुक्लीब्स.ऑर्ग/स्टेटस.हटम्ल](https://cxx.uclibc.org/status.html)

हमेशा नवीनतम Arduino IDE का उपयोग करें। यह लाइब्रेरी Arduino IDE लाइब्रेरी विशिष्टता rev.2.1 का उपयोग करती है, जिसमें केवल Arduino 1.6.10 और उच्चतर पर उपलब्ध सुविधाएँ हैं। विशिष्टता यहां पाई जा सकती है:

[हत्तपः://गिटहब.कॉम/ार्डुइनो/ार्डुइनो/विकी/ार्डुइनो-आईडीई-1.5:-लाइब्रेरी-स्पेसिफिकेशन](https://github.com/arduino/Arduino/wiki/Arduino-IDE-1.5:-Library-specification)

## लाइसेंस

uClibc++ लाइब्रेरी को LGPL के अंतर्गत लाइसेंस प्राप्त है। यह प्रोजेक्ट अपने द्वारा उपयोग किए जाने वाले अधिकांश कोड के साथ संगत होने के लिए एलजीपीएल को अपनाता है। जब तक अन्यथा उल्लेख न किया गया हो, सभी कोड LGPL के अंतर्गत लाइसेंसीकृत हैं। एक अपवाद है:

-   यहां एंडी ब्राउन की इच्छा के अनुसार src/serstream को BSD लाइसेंस के तहत लाइसेंस दिया गया है:[एचटीटीपी://ैंडिबरौन.में.ुक/टर्म्स-एंड-कंडीशंस/](http://andybrown.me.uk/terms-and-conditions/)
